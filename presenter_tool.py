import pyttsx3
import re
from pathlib import Path

# --- Configuration ---
SCRIPT_FILE = 'presentation_script.txt'
OUTPUT_DIR = 'presentation_audio'
SLIDE_DELIMITER = '---SLIDE---'
# --- End Configuration ---

# Regular expression to find <pause:x> and <tone:x> tags.
# This pattern captures the tag name (e.g., 'pause', 'tone') and its value (e.g., '1000', 'excited').
MARKUP_REGEX = re.compile(r'<(\w+):(\w+)>')

def initialize_tts_engine():
    """Initializes and configures the offline pyttsx3 engine."""
    engine = pyttsx3.init()
    # You can adjust speed (rate) and voice here
    engine.setProperty('rate', 150)  # Speed: Words per minute
    # engine.setProperty('voice', 'some_specific_voice_id') # Optional: Change voice if supported
    return engine

def parse_script(script_path):
    """
    Reads the script file and splits it into a list of slide contents
    based on the SLIDE_DELIMITER.
    """
    try:
        with open(script_path, 'r', encoding='utf-8') as f:
            script_content = f.read()
    except FileNotFoundError:
        print(f"Error: Script file not found at {script_path}")
        return []

    # 1. Split the entire script into segments based on the slide delimiter
    slides = script_content.split(SLIDE_DELIMITER)
    
    # 2. Clean up each slide segment (remove leading/trailing whitespace and empty lines)
    cleaned_slides = [slide.strip() for slide in slides if slide.strip()]
    
    return cleaned_slides

def process_slide_text(text, engine):
    """
    Processes the slide text, converting custom markup tags into 
    SSML-like formatting for the TTS engine.
    
    NOTE ON TONE/EMOTION: pyttsx3/eSpeak has very minimal support for
    emotional tone. The `<tone:x>` tag is included here for future 
    upgrades to more advanced TTS engines (like Coqui TTS or a commercial 
    local engine) but will be ignored for basic pyttsx3/eSpeak. 
    The `<pause:x>` tag is handled using an SSML-compliant break.
    """
    processed_text = text
    
    # Replace headers (e.g., # Section 1) with an actual pause for a natural transition
    processed_text = re.sub(r'#.*?\n', '<break time="500ms"/>', processed_text, flags=re.DOTALL)

    def replace_markup(match):
        tag_type = match.group(1).lower()
        tag_value = match.group(2)
        
        if tag_type == 'pause':
            # Convert <pause:1000> to SSML <break time="1000ms"/>
            # pyttsx3 will pass this SSML to the underlying engine (eSpeak often supports this)
            return f'<break time="{tag_value}ms"/>'
        elif tag_type == 'tone':
            # For pyttsx3/eSpeak, we'll just remove the tone tags but keep the text inside.
            # E.g., <tone:excited>text</tone:excited> becomes "text"
            # More advanced engines would use this value.
            return ''
        return match.group(0) # Return the original text if it's an unrecognized tag

    # Find and process all markup tags
    # The current regex and logic is simplified for basic pyttsx3/eSpeak.
    # For robust handling of tags *containing text* (like <tone>...</tone>), 
    # we would use a more advanced XML parser. For now, we'll use a simple
    # placeholder to remove the tone tags but retain the text.
    
    # Simple cleanup of tags that wrap content (like <tone:excited>text</tone:excited>)
    processed_text = re.sub(r'<tone:\w+>(.*?)</tone:\w+>', r'\1', processed_text, flags=re.DOTALL | re.IGNORECASE)
    
    # Now process the simpler inline tags like <pause:x>
    processed_text = MARKUP_REGEX.sub(replace_markup, processed_text)

    # Clean up any remaining newlines or extra spaces
    return ' '.join(processed_text.split())

def generate_slide_audio(text, slide_number, engine):
    """
    Generates and saves the audio file for a single slide.
    """
    # Create the filename, padding the number for good sorting (e.g., 01, 02)
    filename = f"{str(slide_number).zfill(2)}_slide_audio.mp3"
    output_path = Path(OUTPUT_DIR) / filename
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # 1. Process the text to handle pauses, tones, etc.
    processed_text = process_slide_text(text, engine)
    
    # 2. Add an SSML wrapper to ensure the break tags are interpreted correctly
    # Note: If the TTS engine doesn't recognize SSML, it might speak the tags.
    final_ssml = f'<speak>{processed_text}</speak>'
    
    print(f"Generating audio for Slide {slide_number} -> {filename}...")
    
    # Save the synthesized speech to an audio file
    engine.save_to_file(final_ssml, str(output_path))
    
    # NOTE: We only call runAndWait() once outside the loop to wait for all files 
    # to be queued and generated by the driver, which is more efficient.
    # We will run this outside in the main function.
    
    # For immediate testing/debugging, you can uncomment the line below:
    # engine.runAndWait() 
    
    print(f"Queued generation for Slide {slide_number}.")
    return True

def main():
    """
    Main execution function: parses the script and generates all audio files.
    """
    engine = initialize_tts_engine()
    
    # 1. Parse the script file into a list of slide texts
    slides = parse_script(SCRIPT_FILE)
    
    if not slides:
        print("Script processing finished with no slides to generate.")
        return

    print(f"Found {len(slides)} slides to process.")
    
    # 2. Loop through each slide and queue the audio generation
    for i, slide_text in enumerate(slides, 1):
        generate_slide_audio(slide_text, i, engine)
    
    # 3. Wait for all queued audio files to be generated (pyttsx3 requirement)
    print("\nStarting TTS generation process. Please wait...")
    engine.runAndWait()
    
    print("\nâœ… All presenter audio files have been successfully created!")
    print(f"Check the '{OUTPUT_DIR}/' folder for your MP3 files.")
    
if __name__ == "__main__":
    main()